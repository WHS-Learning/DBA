% --- chapters/chap2.tex ---
% KORRIGIERTE VERSION (Fehler in Z. 208 und Bildpfad Z. 38 behoben)

\chapter{SQL}

\section{CREATE TABLE}
Tabellen können über den \texttt{CREATE TABLE}-Befehl erstellt werden.

% Syntax-Definitionen sind in 'quote' oder 'verbatim' besser lesbar
% \textit{} für Platzhalter, \texttt{} für Schlüsselwörter
\begin{quote}
\texttt{CREATE TABLE} \textit{tabellenname} ( \\
\quad \textit{spaltenname\_1} \textit{datentyp\_1} [\texttt{NOT NULL}], \\
\quad \textit{spaltenname\_n} \textit{datentyp\_n} [\texttt{NOT NULL}], \\
\quad [\texttt{PRIMARY KEY} (\textit{spalte\_a, spalte\_b, \dots})], \\
\quad [\texttt{FOREIGN KEY} (\textit{spalte\_c}) \texttt{REFERENCES} \\
\qquad \textit{andere\_tabelle}(\textit{spalte\_d}), \dots] \\
)
\end{quote}
\noindent Zwischen eckigen Klammern \texttt{[]} stehende Teile sind optional.

\subsection{Beispiel 1}

% Code-Beispiele gehören in eine 'lstlisting'-Umgebung
\begin{lstlisting}[language=SQL, caption={Beispiel 1: Erstellung der Tabelle 'film'}]
CREATE TABLE film (
    fid INTEGER NOT NULL,
    titel VARCHAR(50),
    erscheinungsdatum DATE,
    genre VARCHAR(30),
    PRIMARY KEY (fid)
);
\end{lstlisting}

% Bilder gehören in eine 'figure'-Umgebung für Captions und Labels
\begin{figure}[htbp]
    \centering
    % --- KORRIGIERTER BILD-PFAD ---
    \includegraphics[width=0.8\textwidth]{assets/chap2/CREATE_TABLE_example_1.png}
    \caption{Resultierende Tabellenstruktur für 'film'}
    \label{fig:create_table_example_1}
\end{figure}

\subsection{Beispiel 2}

\begin{lstlisting}[language=SQL, caption={Beispiel 2: Zusammengesetzter Primärschlüssel}]
CREATE TABLE film2 (
    titel VARCHAR(50),
    erscheinungsdatum DATE,
    genre VARCHAR(30),
    PRIMARY KEY (titel, erscheinungsdatum)
);
\end{lstlisting}
\noindent (\texttt{titel}, \texttt{erscheinungsdatum}) ist ein zusammengesetzter Primärschlüssel. In dieser Modellierung können keine zwei Filme mit dem gleichen Titel am selben Tag erscheinen.

\subsection{Schlüsselgenerierung}
Schlüssel können durch verschiedene Strategien generiert werden:

\subsubsection{GENERATED AS IDENTITY}
Varianten:
\begin{itemize}
    \item \texttt{GENERATED ALWAYS AS IDENTITY} (Immer generiert, manuelles Einfügen verboten)
    \item \texttt{GENERATED BY DEFAULT AS IDENTITY} (Standardmäßig generiert, manuelles Einfügen erlaubt)
\end{itemize}

\begin{lstlisting}[language=SQL, caption={Schlüsselgenerierung mit \texttt{IDENTITY}}]
CREATE TABLE film (
    fid INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    titel TEXT,
    ...
);
\end{lstlisting}
\noindent Hinweis: Bei \texttt{BY DEFAULT} kann manuell ein Wert gesetzt werden.

\subsubsection{Manuelle Sequenzen}
Volle Kontrolle über Startwert und Inkrement:

\begin{lstlisting}[language=SQL, caption={Manuelle Sequenzenerstellung und -nutzung}]
CREATE SEQUENCE user_id_seq START 100;

CREATE TABLE schauspieler (
    sid INT PRIMARY KEY DEFAULT nextval('user_id_seq'),
    vorname TEXT,
    ...
);
\end{lstlisting}
Vorteil: Flexibel, z. B. anpassbare Startwerte. \\
Nachteil: Verwaltung der Sequenz liegt in der Hand des Entwicklers.

\subsubsection{UUIDs}
Globale Eindeutigkeit ohne Sequenzen (benötigt ggf. Erweiterung):

\begin{lstlisting}[language=SQL, caption={UUIDs als Primärschlüssel (PostgreSQL)}]
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE schauspieler (
    sid UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT,
    ...
);
\end{lstlisting}
Vorteile: Keine Kollisionen bei verteilten Systemen, kein zentraler Zähler nötig. \\
Nachteil: IDs sind länger (16 Bytes) und schwerer lesbar.

\subsubsection{Eigene Generatoren / Trigger}
Komplexe ID-Logik mit Funktionen (z.B. in \texttt{plpgsql}) möglich.

\begin{lstlisting}[language=SQL, caption={Eigener ID-Generator mit \texttt{plpgsql} (PostgreSQL)}]
CREATE SEQUENCE film_seq;

CREATE FUNCTION generate_film_id() RETURNS TEXT AS $$
BEGIN
    RETURN 'FID-' || to_char(NOW(), 'YYYYMMDD') 
           || '-' || nextval('film_seq');
END;
$$ LANGUAGE plpgsql;

CREATE TABLE film (
    fid TEXT PRIMARY KEY DEFAULT generate_film_id(),
    titel TEXT,
    ...
);
\end{lstlisting}

\subsection{Beispiel 3: Fremdschlüssel}

\begin{lstlisting}[language=SQL, caption={Beispiel 3: Definition von Fremdschlüsseln}]
CREATE TABLE spielt_in (
    fid INTEGER NOT NULL,
    sid INTEGER NOT NULL,
    FOREIGN KEY (fid) REFERENCES film(fid),
    FOREIGN KEY (sid) REFERENCES schauspieler(sid)
);
\end{lstlisting}
Ein Fremdschlüssel verknüpft Datensätze zwischen Tabellen. Er verweist auf den Primärschlüssel einer anderen Tabelle und stellt sicher, dass keine Datensätze verwaisen (Referenzielle Integrität).

\begin{figure}[htbp]
    \centering
    % --- ICH NEHME AN, DIESER PFAD IST AUCH SO ÄHNLICH ---
    \includegraphics[width=0.8\textwidth]{assets/chap2/fremdschlüssel.png}
    \caption{Visualisierung eines Fremdschlüssels}
    \label{fig:fremdschluessel}
\end{figure}

\subsubsection*{Referenzielle Aktionen}
Definieren, was bei Lösch- oder Update-Operationen passieren soll:

\begin{lstlisting}[language=SQL, caption={Referenzielle Aktionen definieren}]
FOREIGN KEY (kunde_id) REFERENCES kunden(id)
    ON DELETE CASCADE
    ON UPDATE SET NULL;
\end{lstlisting}

Wichtige Varianten:
% 'description' ist perfekt für "Begriff - Erklärung" Listen
\begin{description}
    \item[ON DELETE CASCADE] Löscht abhängige Datensätze automatisch mit.
    \item[ON DELETE SET NULL] Setzt Fremdschlüssel in abhängigen Datensätzen auf \texttt{NULL}.
    \item[ON DELETE RESTRICT] Verhindert die Löschung, wenn Abhängigkeiten bestehen (Standard).
    \item[ON UPDATE CASCADE] Aktualisiert die Fremdschlüsselwerte, wenn der referenzierte Schlüssel sich ändert.
\end{description}

\subsection{Datentypen}
PostgreSQL unterstützt eine Vielzahl von Datentypen.

\subsubsection{Numerische Typen}
\begin{description}
    \item[SMALLINT] 2 Byte, von -32.768 bis 32.767
    \item[INTEGER] 4 Byte, Standard-Ganzzahl
    \item[BIGINT] 8 Byte, für sehr große Ganzzahlen
    \item[REAL] 4 Byte Fließkommazahl (einfache Genauigkeit)
    \item[DOUBLE PRECISION] 8 Byte Fließkommazahl (doppelte Genauigkeit)
    \item[NUMERIC(p, s)] Exakte Dezimalzahl (z.B. \texttt{NUMERIC(10, 2)}: 10 Stellen gesamt, 2 Nachkommastellen). Ideal für Geldbeträge.
\end{description}

\subsubsection{Zeichenketten}
\begin{description}
    \item[CHAR(n)] Feste Länge (wird mit Leerzeichen aufgefüllt)
    \item[VARCHAR(n)] Variable Länge, auf \textit{n} Zeichen begrenzt
    \item[TEXT] Variable, unbegrenzte Länge
\end{description}

\subsubsection{Datums- und Zeit-Typen}
\begin{description}
    \item[DATE] Nur Datum, z.B. \texttt{'2025-11-04'}
    \item[TIME] Nur Uhrzeit, z.B. \texttt{'08:30:00'}
    \item[TIMETZ] Uhrzeit mit Zeitzone, z.B. \texttt{'08:30:00+01'}
    \item[TIMESTAMP] Datum und Uhrzeit, z.B. \texttt{'2025-11-04 08:30:00'}
    \item[TIMESTAMPTZ] Datum und Uhrzeit mit Zeitzone (bevorzugt für globale Anwendungen)
    \item[INTERVAL] Zeitspanne, z.B. \texttt{'1 day'}, \texttt{'3 hours'}
\end{description}

\subsubsection{Sonstige Typen}
\begin{description}
    \item[BOOLEAN] \texttt{TRUE}, \texttt{FALSE} oder \texttt{NULL}
    \item[UUID] Universally Unique Identifiers
    \item[INET] IP-Adressen (IPv4 oder IPv6)
    \item[BYTEA] Binärdaten (z.B. Bilder, Dateien)
\end{description}

\subsubsection{Strukturierte Datentypen}
\begin{description}
    \item[Arrays] Jeder Datentyp kann als Array gespeichert werden, z.B. \texttt{INT[]}.
    \item[JSON/JSONB] Speicherung von strukturierten Daten. \texttt{JSONB} ist die binäre, indizierbare Variante und wird meist bevorzugt.
\end{description}

\subsubsection{Benutzerdefinierte Datentypen}
\begin{description}
    \item[Enumerations (ENUM)] \texttt{CREATE TYPE status AS ENUM ('neu', 'aktiv', 'archiviert');}
    % --- HIER IST DIE KORREKTUR: "positive_int" -> "positive int" ---
    \item[Domänen (Domains)] \texttt{CREATE DOMAIN positive int AS INT CHECK (VALUE > 0);}
    \item[Zusammengesetzte Typen] \texttt{CREATE TYPE adresse AS (strasse TEXT, plz INT);}
\end{description}
Vorteil: Eigene Typen fördern Konsistenz und Wiederverwendung.

\section{DROP TABLE}
Tabellen können über \texttt{DROP TABLE} gelöscht werden.
\begin{lstlisting}[language=SQL]
DROP TABLE tabellenname;
\end{lstlisting}
\noindent Der Befehl wird zurückgewiesen, wenn noch Abhängigkeiten (Sichten, Fremdschlüssel) existieren.
Wird eine Tabelle gelöscht, gehen auch alle Daten in der Tabelle unwiderruflich verloren.

\section{ALTER TABLE}
Tabellen können über \texttt{ALTER TABLE \textit{tabelle} \textit{modifikation}} geändert werden.

Als \textit{modifikation} stehen Anweisungen zur Verfügung wie:
\begin{itemize}
    \item \texttt{ADD COLUMN \textit{spaltendefinition}}
    \item \texttt{DROP COLUMN \textit{spaltenname}}
    \item \texttt{ALTER COLUMN \textit{spaltenname} \textit{typ} \dots}
    \item \texttt{RENAME COLUMN \textit{alt} TO \textit{neu}}
    \item \texttt{ADD CONSTRAINT \textit{...}}
\end{itemize}

\begin{lstlisting}[language=SQL, caption={Beispiel 1: Spalte hinzufügen}]
ALTER TABLE schauspieler
ADD COLUMN geburtsdatum DATE;
\end{lstlisting}

\begin{lstlisting}[language=SQL, caption={Beispiel 2: Spalte mit Standardwert hinzufügen}]
ALTER TABLE schauspieler
ADD COLUMN hat_oskar BOOLEAN NOT NULL DEFAULT false;
\end{lstlisting}

\section{INSERT}
Fügt neue Datensätze (Zeilen) in eine Tabelle ein.
\begin{lstlisting}[language=SQL, caption={Syntax: INSERT}]
INSERT INTO tabelle (attribut_1, ..., attribut_n)
VALUES (attributwert_1, ..., attributwert_n);
\end{lstlisting}
Attribute müssen in derselben Reihenfolge wie die Werte angegeben werden.

\begin{lstlisting}[language=SQL, caption={Beispiel: INSERT}]
INSERT INTO film (fid, titel, erscheinungsdatum, genre)
VALUES (6, 'Kung Fu Panda 4', '2024-03-14', 'Family');
\end{lstlisting}

\section{UPDATE}
Bearbeitet Zeilen, die einer Bedingung entsprechen.
\begin{lstlisting}[language=SQL, caption={Syntax: UPDATE}]
UPDATE tabelle
SET spalte1 = value1, spalte2 = value2, ...
WHERE bedingung;
\end{lstlisting}

\begin{lstlisting}[language=SQL, caption={Beispiel: UPDATE}]
-- Erhöht die Dauer aller Filme um 10 Minuten
UPDATE film
SET dauer = dauer + 10;
\end{lstlisting}

\section{DELETE}
Löscht Zeilen, die einer Bedingung entsprechen.
\begin{lstlisting}[language=SQL, caption={Syntax: DELETE}]
DELETE FROM tabelle
WHERE bedingung;
\end{lstlisting}

\begin{lstlisting}[language=SQL, caption={Beispiel: DELETE}]
DELETE FROM film
WHERE dauer > 120;
\end{lstlisting}
\noindent \textbf{Achtung:} Wird keine \texttt{WHERE}-Bedingung angegeben, werden \textbf{alle} Zeilen aus der Tabelle gelöscht!

\section{SELECT}
Über die \texttt{SELECT}-Anweisung können Daten aus der Datenbank gelesen ("abgefragt") werden. 
Im Allgemeinen ist der \texttt{SELECT}-Befehl aufgeteilt in:

\begin{itemize}
    \item \textbf{SELECT} Projektionsliste (Spalten, die angezeigt werden sollen)
    \item \textbf{FROM} Gibt die verwendeten Tabellen an
    \item \textbf{WHERE} Filtert die Zeilen basierend auf Bedingungen
\end{itemize}

\subsection{Beispiel}
Eine einfache \texttt{SELECT}-Anweisung:
\begin{lstlisting}[language=SQL, caption={Allgemeine SELECT-Struktur}]
SELECT A1, ..., An
FROM R1, ..., Rm
WHERE C;
\end{lstlisting}
\noindent Mit einem Sternchen (\texttt{*}) können alle Spalten aus der Datenbank geholt werden.

\subsection{DISTINCT}
\texttt{DISTINCT} entfernt alle Duplikate aus der Ergebnismenge.
\begin{lstlisting}[language=SQL]
SELECT DISTINCT fid
FROM spielt_in;
\end{lstlisting}

\subsection{WHERE}
Über das \texttt{WHERE} können Bedingungen gesetzt werden, welche erfüllt werden müssen.
Typische Operatoren:
\begin{itemize}
    \item Logische Vergleiche: \texttt{=}, \texttt{<>} (oder \texttt{!=}), \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}
    \item Bereichsprüfungen: \texttt{BETWEEN a AND b}
    \item Wertelisten: \texttt{IN (\dots)}, \texttt{NOT IN (\dots)}
    \item Mustervergleiche: \texttt{LIKE} (mit \texttt{\%} als Platzhalter)
    \item Null-Prüfung: \texttt{IS NULL} / \texttt{IS NOT NULL}
\end{itemize}

\begin{lstlisting}[language=SQL, caption={Beispiele für WHERE-Bedingungen}]
WHERE name LIKE 'A%'; -- Beginnt mit A
WHERE ort IN ('Berlin', 'Hamburg');
WHERE datum BETWEEN '2025-01-01' AND '2025-12-31';
WHERE aktiv IS TRUE;
\end{lstlisting}
\noindent Bedingungen können mit \texttt{AND}, \texttt{OR} und \texttt{NOT} kombiniert werden.

\subsection{Aliase}
Zur besseren Lesbarkeit können in einer SQL-Anfrage Aliase (Umbenennungen) verwendet werden:
\begin{lstlisting}[language=SQL, caption={Aliase für Tabellennamen}]
SELECT DISTINCT titel, rid
FROM film AS f, fuehrt_Regie AS r
WHERE f.fid = r.fid;
\end{lstlisting}
Haben in einer Abfrage mehrere Tabellen Spalten mit dem selben Namen (z.B. \texttt{genre}), muss durch Voranstellen des Alias (z.B. \texttt{f.genre}) explizit angegeben werden, welche Spalte gemeint ist.

Aliase können auch für Spalten, arithmetische Ausdrücke oder Konstanten verwendet werden:
\begin{lstlisting}[language=SQL, caption={Spalten-Aliase}]
SELECT fid, titel,
       dauer + 10 AS kinolaenge,
       '3D' AS vorstellung
FROM film;
\end{lstlisting}

Mögliche Ergebnismenge (formatiert als \texttt{verbatim}):
\begin{verbatim}
 fid | titel         | kinolaenge | vorstellung
-----+---------------+------------+-------------
 1   | Wonka         | 127        | 3D
 2   | Dune:Part Two | 176        | 3D
 3   | Barbie        | 124        | 3D
 4   | Oppenheimer   | 190        | 3D
 5   | John Wick 4   | 179        | 3D
\end{verbatim}

\subsection{WHERE-Klausel (Impliziter JOIN)}
% Hinweis: Dieser Abschnitt wiederholt \subsection{Aliase} teilweise
In der \texttt{WHERE}-Klausel können Bedingungen angegeben werden, die
bestimmte Tupel aus den selektierten Tabellen filtern.
\begin{lstlisting}[language=SQL, caption={Veralteter "impliziter" JOIN-Stil}]
SELECT DISTINCT titel, rid
FROM film AS f, fuehrt_Regie AS r
WHERE f.fid = r.fid;
\end{lstlisting}
Wird keine \texttt{WHERE}-Klausel (oder \texttt{JOIN ON}) angegeben, wird das \textbf{Kartesische Produkt} (jede Zeile aus Tabelle A mit jeder Zeile aus Tabelle B) ausgewertet.

\subsection{JOIN (Expliziter JOIN)}
Die moderne und bevorzugte Art, Tabellen zu verknüpfen:
\begin{lstlisting}[language=SQL, caption={Expliziter JOIN (bevorzugt)}]
SELECT * FROM film AS f
JOIN fuehrt_regie AS r ON f.fid = r.fid;
\end{lstlisting}
Die Verwendung einer \texttt{JOIN \dots ON}-Bedingung ist lesbarer und trennt Verknüpfungs-Logik von der Filter-Logik (die in \texttt{WHERE} bleibt).

\subsection{IN und NOT IN}
Über \texttt{IN} und \texttt{NOT IN} wird getestet, ob ein Wert (nicht) in einer (Unter-)Abfrage oder Liste enthalten ist.

\begin{lstlisting}[language=SQL, caption={NOT IN mit Unterabfrage}]
-- Findet alle Schauspieler, die in keinem Film spielen
SELECT sid, vorname, nachname
FROM schauspieler
WHERE sid NOT IN (
    SELECT sid FROM spielt_in
);
\end{lstlisting}
Es werden also alle Schauspieler ausgegeben, die in keinem Film spielen.

\section{Unterabfragen}
Eine Unterabfrage (Subquery) ist eine SQL-Abfrage, die in eine andere Abfrage (Hauptabfrage) verschachtelt ist. Diese können oft durch \texttt{JOIN}s ersetzt werden, was meist performanter ist.

\begin{lstlisting}[language=SQL, caption={Verschachtelte Unterabfragen}]
-- Findet alle Kunden, deren Gesamtsumme über dem Durchschnitt liegt
SELECT k.name
FROM kunden k
WHERE (
    -- 1. Berechne Summe pro Kunde (korrelierte Unterabfrage)
    SELECT SUM(b.preis)
    FROM besuche b
    WHERE b.kunde_id = k.id
) > (
    -- 2. Berechne Durchschnitt aller Kundensummen
    SELECT AVG(summe)
    FROM (
        -- 2a. Berechne Summe für JEDEN Kunden
        SELECT SUM(b2.preis) AS summe
        FROM besuche b2
        GROUP BY b2.kunde_id
    ) AS durchschnitts_tabelle
);
\end{lstlisting}